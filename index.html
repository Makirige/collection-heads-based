<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Collection Heads Based - BG3</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header>
    <div class="container">
      <h1>Collection Heads Based</h1>
      <p class="subtitle">Head Preset Creator for Baldur's Gate 3</p>
    </div>
  </header>

  <div class="container">
    <div class="controls">
      <div class="search-control">
        <i class="fas fa-search search-icon"></i>
        <input type="text" id="searchInput" placeholder="Search for a preset...">
      </div>
      
      <div class="custom-dropdown" id="raceDropdown">
        <div class="dropdown-selected" data-value="">
          <img src="images/races/150px-Race_Human.png" alt="All Races" class="dropdown-icon" id="raceSelectedIcon">
          <span class="dropdown-text" id="raceSelectedText">All Races</span>
          <i class="fas fa-chevron-down dropdown-arrow"></i>
        </div>
        <div class="dropdown-options" id="raceOptions">
          <!-- Race options will be generated by JavaScript -->
        </div>
      </div>
      
      <div class="custom-dropdown" id="btDropdown">
        <div class="dropdown-selected">
          <img src="images/body_types/body_type_all.png" alt="Body Type" class="dropdown-icon" id="btSelectedIcon">
          <span class="dropdown-text" id="btSelectedText">Body Type</span>
          <i class="fas fa-chevron-down dropdown-arrow"></i>
        </div>
        <div class="dropdown-options" id="btOptions">
          <div class="dropdown-option" data-value="">
            <img src="images/body_types/body_type_all.png" alt="All Types" class="dropdown-icon">
            <span>All Types</span>
          </div>
          <div class="dropdown-option" data-value="bt1">
            <img src="images/body_types/body_type_female.png" alt="Female" class="dropdown-icon">
            <span>Female</span>
          </div>
          <div class="dropdown-option" data-value="bt2">
            <img src="images/body_types/body_type_male.png" alt="Male" class="dropdown-icon">
            <span>Male</span>
          </div>
          <div class="dropdown-option" data-value="bt4">
            <img src="images/body_types/body_type_male_strong.png" alt="Male - Strong" class="dropdown-icon">
            <span>Male - Strong</span>
          </div>
        </div>
      </div>
      
      <div class="control-group">
        <button class="small" onclick="selectAll(true)"><i class="fas fa-check-square"></i> Select All</button>
        <button class="small" onclick="selectAll(false)"><i class="fas fa-square"></i> Deselect All</button>
        <button class="small" onclick="clearStorage()"><i class="fas fa-trash"></i> Clear All</button>
      </div>
    </div>

    <div class="selection-counter" id="selectionCounter">
      <div class="counter-badge">
        <i class="fas fa-check-circle"></i> <span id="selectedCount">0</span> préréglages sélectionnés
      </div>
    </div>

    <div class="mod-count" id="modCount">Loading presets...</div>

    <div class="status" id="statusMessage"></div>
    
    <div class="loader" id="loader">
      <div class="loader-spinner"></div>
      <p>Generating your pack...</p>
    </div>

    <div class="download-progress" id="downloadProgress">
      <div class="progress-header">
        <h3>Preparing your head presets</h3>
        <div class="progress-stats">
          <span id="downloadedCount">0</span> / <span id="totalCount">0</span> files
        </div>
      </div>
      <div class="progress-bar-container">
        <div class="progress-bar" id="progressBar"></div>
      </div>
      <p class="progress-status" id="progressStatus">Initializing download...</p>
    </div>

    <div class="mod-list" id="modList">
      <!-- Mod cards will be generated here via JavaScript -->
    </div>
    
    <button class="generate-btn" id="generateBtn"><i class="fas fa-download"></i> Generate My Pack</button>
  </div>

  <footer>
    <div class="container">
      <p>Collection Heads Based for Baldur's Gate 3 &copy; 2023-2024</p>
    </div>
  </footer>

  <!-- Modal de sélection de race -->
  <div class="modal-overlay" id="raceModal">
    <div class="race-selection-modal">
      <h2>Choose a Race</h2>
      <div class="race-grid" id="raceGrid">
        <!-- Options de race générées par JavaScript -->
      </div>
      <div class="modal-actions">
        <button class="confirm-race-btn" id="confirmRaceBtn" disabled>Confirm</button>
        <button class="skip-race-btn" id="skipRaceBtn">Skip</button>
      </div>
    </div>
  </div>

  <script>
    // DOM Elements
    const searchInput = document.getElementById("searchInput");
    const raceDropdown = document.getElementById("raceDropdown");
    const btDropdown = document.getElementById("btDropdown");
    const modList = document.getElementById("modList");
    const modCount = document.getElementById("modCount");
    const loader = document.getElementById("loader");
    const statusMessage = document.getElementById("statusMessage");
    const generateBtn = document.getElementById("generateBtn");
    const raceModal = document.getElementById("raceModal");
    const raceGrid = document.getElementById("raceGrid");
    const confirmRaceBtn = document.getElementById("confirmRaceBtn");
    const skipRaceBtn = document.getElementById("skipRaceBtn");
    
    // State
    let mods = [];
    let filteredMods = [];
    let selectedRace = "";
    let isGenerating = false; // Variable pour le debouncing du bouton de génération
    let availableRaces = []; // Stocke les races effectivement disponibles
    
    // Configuration des icônes de races (utilisée pour les races disponibles uniquement)
    const raceIcons = {
      '': 'images/races/150px-Race_Human.png', // Option "Toutes les races"
      'dragonborn': 'images/races/150px-Race_Dragonborn.png',
      'drow': 'images/races/150px-Race_Drow.png',
      'dwarf': 'images/races/150px-Race_Dwarf.png',
      'elf': 'images/races/150px-Race_Elf.png',
      'githyanki': 'images/races/150px-Race_Githyanki.png',
      'gnome': 'images/races/150px-Race_Gnome.png',
      'half-elf': 'images/races/150px-Race_Half-Elf.png',
      'halfling': 'images/races/150px-Race_Halfling.png',
      'half-orc': 'images/races/150px-Race_Half-Orc.png',
      'human': 'images/races/150px-Race_Human.png',
      'tiefling': 'images/races/150px-Race_Tiefling.png'
    };
    
    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
      loadMods();
      setupEventListeners();
      loadStateFromStorage();
    });
    
    function setupEventListeners() {
      searchInput.addEventListener("input", filterMods);
      
      // Event listeners for dropdown headers
      document.querySelector('#raceDropdown .dropdown-selected').addEventListener('click', openRaceDropdown);
      document.querySelector('#btDropdown .dropdown-selected').addEventListener('click', openBtDropdown);
      
      // Add event listener to body type options
      document.querySelectorAll('#btOptions .dropdown-option').forEach(option => {
        option.addEventListener('click', (e) => {
          e.stopPropagation();
          selectBtOption(option);
        });
      });
      
      confirmRaceBtn.addEventListener("click", closeRaceModal);
      skipRaceBtn.addEventListener("click", skipRaceSelection);
      
      // Save state when inputs change
      searchInput.addEventListener("input", saveStateToStorage);
      
      // Save selected mods when checkboxes change
      document.addEventListener("change", function(e) {
        if (e.target.type === "checkbox") {
          saveSelectedModsToStorage();
        }
      });
      
      // Ajout du gestionnaire d'événement pour le bouton de génération avec debounce
      generateBtn.addEventListener("click", debounce(generatePack, 1000));
    }
    
    // Load mods from JSON file
    async function loadMods() {
      try {
        const response = await fetch('mods.json');
        if (!response.ok) throw new Error('Failed to load mods data');
        
        mods = await response.json();
        filteredMods = [...mods];
        
        // Identifier les races disponibles
        identifyAvailableRaces();
        
        // Configurer les interfaces après avoir identifié les races disponibles
        setupRaceModal();
        setupCustomDropdowns();
        
        renderMods();
        updateModCount();
        updateFilterCounts();
        showStatus('success', `${mods.length} head presets loaded successfully!`);
      } catch (error) {
        console.error("Error loading mods:", error);
        showStatus('error', 'Error loading presets. Please refresh the page.');
      }
    }
    
    // Identifie les races disponibles à partir des données chargées
    function identifyAvailableRaces() {
      // Ajouter l'option "Toutes les races" par défaut
      availableRaces = [{ 
        id: '', 
        name: 'All Races', 
        icon: raceIcons[''],
        count: mods.length
      }];
      
      // Compteur pour les races
      const raceCounts = {};
      
      // Compter les occurrences de chaque race
      mods.forEach(mod => {
        if (mod.race) {
          raceCounts[mod.race] = (raceCounts[mod.race] || 0) + 1;
        }
      });
      
      // Créer les entrées pour les races qui ont des préréglages
      for (const raceId in raceCounts) {
        if (raceCounts[raceId] > 0 && raceIcons[raceId]) {
          availableRaces.push({
            id: raceId,
            name: getRaceName(raceId),
            icon: raceIcons[raceId],
            count: raceCounts[raceId]
          });
        }
      }
      
      // Trier les races par ordre alphabétique (après "Toutes les races")
      availableRaces.sort((a, b) => {
        if (a.id === '') return -1;
        if (b.id === '') return 1;
        return a.name.localeCompare(b.name);
      });
    }
    
    // Setup race selection modal
    function setupRaceModal() {
      // Vider le grid actuel
      raceGrid.innerHTML = '';
      
      // Générer les options de race (uniquement celles disponibles, sans "Toutes les races")
      availableRaces.filter(race => race.id !== '').forEach(race => {
        const option = document.createElement('div');
        option.className = 'race-option';
        option.dataset.race = race.id;
        
        option.innerHTML = `
          <img src="${race.icon}" alt="${race.name}" onerror="this.onerror=null; this.src='data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2260%22%20height%3D%2260%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Ctext%20x%3D%2250%25%22%20y%3D%2250%25%22%20font-family%3D%22Arial%22%20font-size%3D%2220%22%20fill%3D%22%23ffffff%22%20text-anchor%3D%22middle%22%20dominant-baseline%3D%22middle%22%3E${race.name.charAt(0)}%3C%2Ftext%3E%3C%2Fsvg%3E';">
          <div class="race-name">${race.name}</div>
        `;
        
        option.addEventListener('click', () => {
          // Désélectionner tous les autres
          document.querySelectorAll('.race-option').forEach(el => el.classList.remove('active'));
          
          // Sélectionner celui-ci
          option.classList.add('active');
          selectedRace = race.id;
          
          // Activer le bouton de confirmation
          confirmRaceBtn.disabled = false;
        });
        
        raceGrid.appendChild(option);
      });
    }
    
    // Close modal and apply race filter
    function closeRaceModal() {
      if (selectedRace) {
        // Trouver l'icône correcte pour la race sélectionnée
        const raceData = availableRaces.find(race => race.id === selectedRace);
        const raceName = raceData ? raceData.name : getRaceName(selectedRace);
        const raceIcon = raceData ? raceData.icon : raceIcons[selectedRace] || `images/races/150px-Race_${selectedRace.charAt(0).toUpperCase() + selectedRace.slice(1)}.png`;
        
        // Mettre à jour le dropdown sélectionné
        const selectedText = document.getElementById('raceSelectedText');
        const selectedIcon = document.getElementById('raceSelectedIcon');
        const dropdown = document.getElementById('raceDropdown');
        
        selectedText.textContent = raceName;
        selectedIcon.src = raceIcon;
        selectedIcon.alt = raceName;
        
        dropdown.querySelector('.dropdown-selected').dataset.value = selectedRace;
        
        // Marquer l'option sélectionnée
        document.querySelectorAll('#raceOptions .dropdown-option').forEach(opt => {
          opt.classList.toggle('selected', opt.dataset.value === selectedRace);
        });
        
        filterMods();
        raceModal.style.display = 'none';
      }
    }
    
    // Skip race selection
    function skipRaceSelection() {
      raceModal.style.display = 'none';
    }
    
    // Filter mods based on search and filters
    function filterMods() {
      // Store current selections before filtering
      const selectedModIds = {};
      document.querySelectorAll('.mod-card input[type=checkbox]:checked').forEach(checkbox => {
        const modId = checkbox.closest('.mod-card').dataset.id;
        selectedModIds[modId] = true;
      });
      
      const query = searchInput.value.toLowerCase();
      const raceSelected = document.querySelector('#raceDropdown .dropdown-selected');
      const btSelected = document.querySelector('#btDropdown .dropdown-selected');
      const race = raceSelected.dataset.value;
      const bt = btSelected.dataset.value;
      
      filteredMods = mods.filter(mod => {
        const matchName = mod.name.toLowerCase().includes(query);
        const matchRace = race === "" || mod.race === race;
        const matchBT = bt === "" || mod.bodyType === bt;
        
        return matchName && matchRace && matchBT;
      });
      
      renderMods();
      updateModCount();
      
      // Restore selections after rendering
      applyStoredSelections(selectedModIds);
    }
    
    // Render mod cards
    function renderMods() {
      // Save current selections before clearing
      const currentSelections = {};
      document.querySelectorAll('.mod-card').forEach(card => {
        const checkbox = card.querySelector('input[type=checkbox]');
        if (checkbox && checkbox.checked) {
          currentSelections[card.dataset.id] = true;
        }
      });
      
      modList.innerHTML = '';
      
      if (filteredMods.length === 0) {
        modList.innerHTML = `<p style="grid-column: 1/-1; text-align: center; padding: 2rem;">No presets found matching these criteria.</p>`;
        return;
      }
      
      filteredMods.forEach(mod => {
        const card = document.createElement('label');
        card.className = 'mod-card';
        card.dataset.id = mod.id;
        
        // Get race name and icon
        const raceName = getRaceName(mod.race);
        const raceIcon = raceIcons[mod.race] || 'images/races/150px-Race_Human.png';
        const bodyTypeName = getBodyTypeName(mod.bodyType);
        
        // Check if this mod was previously selected
        const isChecked = currentSelections[mod.id] ? 'checked' : '';
        
        // Ajouter le lien original s'il existe
        const originalLink = mod.originalLink 
          ? `<a href="${mod.originalLink}" class="original-link" target="_blank" title="View original mod" onclick="event.stopPropagation();">
              <i class="fas fa-external-link-alt"></i>
            </a>` 
          : '';
        
        card.innerHTML = `
          <input type="checkbox" value="${mod.downloadUrl}" ${isChecked} />
          <div class="image-container">
            <img src="${mod.imagePath}" alt="${mod.displayName}" />
            ${originalLink}
          </div>
          <div class="content">
            <div class="title">${mod.displayName}</div>
            <div class="badges">
              <div class="badge race-badge">
                <img src="${raceIcon}" alt="${raceName}" class="badge-icon" />
                ${raceName}
              </div>
              <div class="badge"><i class="fas fa-venus-mars"></i> ${bodyTypeName}</div>
            </div>
          </div>
        `;
        
        modList.appendChild(card);
      });
    }
    
    // Update mod count display
    function updateModCount() {
      const selectedCount = document.querySelectorAll('.mod-card input[type=checkbox]:checked').length;
      modCount.textContent = `Showing ${filteredMods.length} of ${mods.length} presets (${selectedCount} selected)`;
      
      // Mettre à jour également le nouveau compteur de sélection
      document.getElementById('selectedCount').textContent = selectedCount;
      
      // Afficher ou masquer le compteur de sélection en fonction du nombre
      const selectionCounter = document.getElementById('selectionCounter');
      if (selectedCount > 0) {
        selectionCounter.classList.add('show');
      } else {
        selectionCounter.classList.remove('show');
      }
    }
    
    // Get race name
    function getRaceName(race) {
      const raceMap = {
        'dragonborn': 'Dragonborn',
        'drow': 'Drow',
        'dwarf': 'Dwarf',
        'elf': 'Elf',
        'githyanki': 'Githyanki',
        'gnome': 'Gnome',
        'half-elf': 'Half-Elf',
        'halfling': 'Halfling',
        'half-orc': 'Half-Orc',
        'human': 'Human',
        'tiefling': 'Tiefling'
      };
      return raceMap[race] || race;
    }
    
    // Get body type name
    function getBodyTypeName(bt) {
      const btMap = {
        'bt1': 'Female',
        'bt2': 'Male',
        'bt4': 'Male - Strong'
      };
      return btMap[bt] || bt.toUpperCase();
    }
    
    // Select/Deselect all checkboxes
    function selectAll(state) {
      document.querySelectorAll(".mod-card input[type=checkbox]").forEach(checkbox => {
        checkbox.checked = state;
      });
      saveSelectedModsToStorage();
    }
    
    // Show status message
    function showStatus(type, message) {
      statusMessage.textContent = message;
      statusMessage.className = `status ${type}`;
      statusMessage.style.display = 'block';
      
      setTimeout(() => {
        statusMessage.style.display = 'none';
      }, 5000);
    }
    
    // Generate mod pack
    async function generatePack() {
      // Empêcher les clics multiples pendant le traitement
      if (isGenerating) return;
      isGenerating = true;
      
      const selected = [...document.querySelectorAll('input[type=checkbox]:checked')].map(el => el.value);
      
      if (selected.length === 0) {
        showStatus('error', 'Please select at least one preset to generate your pack.');
        isGenerating = false;
        return;
      }
      
      try {
        // Initialiser l'interface de progression
        document.getElementById('downloadedCount').textContent = '0';
        document.getElementById('totalCount').textContent = selected.length;
        document.getElementById('progressBar').style.width = '0%';
        document.getElementById('progressStatus').textContent = 'Initializing download...';
        document.getElementById('downloadProgress').style.display = 'block';
        generateBtn.disabled = true;
        
        const zip = new JSZip();
        const folder = zip.folder("Collection_Heads_Based");
        let failedFiles = [];
        let downloadedCount = 0;
        
        for (const file of selected) {
          try {
            // Mettre à jour le statut
            document.getElementById('progressStatus').textContent = `Downloading ${getFileNameFromUrl(file)}...`;
            
            const response = await fetch(file);
            if (!response.ok) throw new Error('Failed to fetch');
            
            const blob = await response.blob();
            // Extract the name parameter from the URL if it exists
            let fileName;
            const url = new URL(file);
            const nameParam = url.searchParams.get('n');
            if (nameParam) {
              fileName = decodeURIComponent(nameParam);
            } else {
              fileName = decodeURIComponent(file.split("/").pop().split("?")[0]);
            }
            folder.file(fileName, blob);
            
            // Mettre à jour le compteur et la barre de progression
            downloadedCount++;
            document.getElementById('downloadedCount').textContent = downloadedCount;
            const progressPercentage = (downloadedCount / selected.length) * 100;
            document.getElementById('progressBar').style.width = `${progressPercentage}%`;
          } catch (error) {
            console.error("Error fetching", file, error);
            failedFiles.push(file);
            
            // Mettre à jour le statut pour l'échec
            document.getElementById('progressStatus').textContent = `Failed to download ${getFileNameFromUrl(file)}`;
            await new Promise(resolve => setTimeout(resolve, 1000)); // Pause brève pour montrer l'erreur
          }
        }
        
        // Finalisation du zip
        document.getElementById('progressStatus').textContent = 'Finalizing your pack...';
        
        const content = await zip.generateAsync({ 
          type: "blob",
          compression: "DEFLATE",
          compressionOptions: { level: 5 },
          // Ajouter un callback de progression pour la génération du ZIP
          onUpdate: metadata => {
            const compressionPercent = Math.round(metadata.percent);
            document.getElementById('progressBar').style.width = `${compressionPercent}%`;
          }
        });
        
        document.getElementById('progressStatus').textContent = 'Download ready!';
        saveAs(content, "Collection_Heads_Based.zip");
        
        if (failedFiles.length > 0) {
          showStatus('error', `${failedFiles.length} file(s) could not be downloaded.`);
        } else {
          showStatus('success', 'Your pack has been generated successfully!');
        }
      } catch (error) {
        console.error("Error generating pack:", error);
        showStatus('error', 'An error occurred while generating the pack.');
      } finally {
        // Cacher l'interface de progression après un court délai
        setTimeout(() => {
          document.getElementById('downloadProgress').style.display = 'none';
          generateBtn.disabled = false;
          isGenerating = false;
        }, 2000);
      }
    }
    
    // Fonction utilitaire pour obtenir un nom de fichier à partir d'une URL
    function getFileNameFromUrl(url) {
      try {
        const urlObj = new URL(url);
        const nameParam = urlObj.searchParams.get('n');
        if (nameParam) {
          return decodeURIComponent(nameParam);
        }
        return decodeURIComponent(url.split("/").pop().split("?")[0]);
      } catch (e) {
        return url.split("/").pop().split("?")[0];
      }
    }
    
    // Save state to localStorage
    function saveStateToStorage() {
      const state = {
        searchQuery: searchInput.value,
        raceFilter: document.querySelector('#raceDropdown .dropdown-selected').dataset.value,
        btFilter: document.querySelector('#btDropdown .dropdown-selected').dataset.value
      };
      localStorage.setItem('headPresetState', JSON.stringify(state));
    }
    
    // Save selected mods to localStorage
    function saveSelectedModsToStorage() {
      const selectedModIds = {};
      document.querySelectorAll('.mod-card input[type=checkbox]:checked').forEach(checkbox => {
        const modId = checkbox.closest('.mod-card').dataset.id;
        selectedModIds[modId] = true;
      });
      localStorage.setItem('selectedHeadPresets', JSON.stringify(selectedModIds));
      
      // Mettre à jour le compteur de présélections sélectionnées
      updateModCount();
    }
    
    // Load state from localStorage
    function loadStateFromStorage() {
      // Load filter state
      const savedState = localStorage.getItem('headPresetState');
      if (savedState) {
        const state = JSON.parse(savedState);
        searchInput.value = state.searchQuery || '';
        
        if (state.raceFilter) {
          const raceOption = document.querySelector(`#raceOptions .dropdown-option[data-value="${state.raceFilter}"]`);
          if (raceOption) {
            selectRaceOption(
              raceOption.dataset.value,
              raceOption.dataset.name || raceOption.querySelector('span').textContent,
              raceOption.dataset.icon || raceOption.querySelector('img').src
            );
          }
        }
        
        if (state.btFilter) {
          const btOption = document.querySelector(`#btOptions .dropdown-option[data-value="${state.btFilter}"]`);
          if (btOption) {
            selectBtOption(btOption);
          }
        }
        
        // Apply filters
        if (state.searchQuery || state.raceFilter || state.btFilter) {
          filterMods();
        }
      }
      
      // Mise à jour des compteurs de filtre
      if (mods.length > 0) {
        updateFilterCounts();
      }
      
      // Check if we need to show race modal
      const hasVisitedBefore = localStorage.getItem('hasVisitedBefore');
      if (hasVisitedBefore) {
        raceModal.style.display = 'none';
      } else {
        localStorage.setItem('hasVisitedBefore', 'true');
      }
      
      // Load selected mods after a slight delay to ensure DOM is ready
      setTimeout(() => {
        const savedSelectedMods = localStorage.getItem('selectedHeadPresets');
        if (savedSelectedMods) {
          const selectedModIds = JSON.parse(savedSelectedMods);
          applyStoredSelections(selectedModIds);
        }
      }, 300);
    }
    
    // Apply stored selections to checkboxes
    function applyStoredSelections(selectedModIds) {
      document.querySelectorAll('.mod-card').forEach(card => {
        const modId = card.dataset.id;
        if (selectedModIds[modId]) {
          const checkbox = card.querySelector('input[type=checkbox]');
          if (checkbox) {
            checkbox.checked = true;
          }
        }
      });
    }
    
    // Clear storage and reset page
    function clearStorage() {
      localStorage.removeItem('headPresetState');
      localStorage.removeItem('selectedHeadPresets');
      
      // Reset UI
      searchInput.value = '';
      
      // Reset race dropdown
      const defaultRaceOption = document.querySelector('#raceOptions .dropdown-option[data-value=""]');
      if (defaultRaceOption) {
        selectRaceOption('', 'All Races', defaultRaceOption.querySelector('img').src);
      }
      
      // Reset body type dropdown
      const defaultBtOption = document.querySelector('#btOptions .dropdown-option[data-value=""]');
      if (defaultBtOption) {
        selectBtOption(defaultBtOption);
      }
      
      // Uncheck all checkboxes
      document.querySelectorAll('.mod-card input[type=checkbox]').forEach(checkbox => {
        checkbox.checked = false;
      });
      
      // Reload mods view
      filterMods();
      
      // Mise à jour des compteurs de filtre
      updateFilterCounts();
      
      showStatus('success', 'All filters and selections have been cleared.');
    }
    
    // Update filter counts
    function updateFilterCounts() {
      // Count races
      const raceCounts = {};
      mods.forEach(mod => {
        raceCounts[mod.race] = (raceCounts[mod.race] || 0) + 1;
      });
      
      // Update race filter options
      document.querySelectorAll('#raceOptions .dropdown-option').forEach(option => {
        const value = option.dataset.value;
        const span = option.querySelector('span');
        
        if (value === "") {
          span.textContent = `All Races (${mods.length})`;
        } else {
          const count = raceCounts[value] || 0;
          const raceName = getRaceName(value);
          span.textContent = `${raceName} (${count})`;
        }
      });
      
      // Count body types
      const btCounts = {};
      mods.forEach(mod => {
        btCounts[mod.bodyType] = (btCounts[mod.bodyType] || 0) + 1;
      });
      
      // Update body type filter options
      document.querySelectorAll('#btOptions .dropdown-option').forEach(option => {
        const value = option.dataset.value;
        const span = option.querySelector('span');
        
        if (value === "") {
          span.textContent = `All Types (${mods.length})`;
        } else {
          const count = btCounts[value] || 0;
          const btName = getBodyTypeName(value);
          span.textContent = `${btName} (${count})`;
        }
      });
    }

    // Setup custom dropdowns
    function setupCustomDropdowns() {
      // Setup race dropdown options
      const raceOptions = document.getElementById('raceOptions');
      
      // Vider les options existantes
      raceOptions.innerHTML = '';
      
      // Create race options (uniquement pour les races disponibles)
      availableRaces.forEach(race => {
        const option = document.createElement('div');
        option.className = 'dropdown-option';
        option.dataset.value = race.id;
        option.dataset.icon = race.icon;
        option.dataset.name = race.name;
        
        option.innerHTML = `
          <img src="${race.icon}" alt="${race.name}" class="dropdown-icon">
          <span>${race.name} (${race.count})</span>
        `;
        
        option.addEventListener('click', (e) => {
          e.stopPropagation();
          selectRaceOption(race.id, race.name, race.icon);
        });
        
        raceOptions.appendChild(option);
      });
      
      // Add click outside to close dropdowns
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.custom-dropdown')) {
          closeAllDropdowns();
        }
      });
    }
    
    // Open race dropdown
    function openRaceDropdown(e) {
      e.stopPropagation();
      const options = document.getElementById('raceOptions');
      const btOptions = document.getElementById('btOptions');
      const raceSelected = document.querySelector('#raceDropdown .dropdown-selected');
      const btSelected = document.querySelector('#btDropdown .dropdown-selected');
      
      btOptions.classList.remove('show');
      btSelected.classList.remove('active');
      
      options.classList.toggle('show');
      raceSelected.classList.toggle('active');
    }
    
    // Open body type dropdown
    function openBtDropdown(e) {
      e.stopPropagation();
      const options = document.getElementById('btOptions');
      const raceOptions = document.getElementById('raceOptions');
      const raceSelected = document.querySelector('#raceDropdown .dropdown-selected');
      const btSelected = document.querySelector('#btDropdown .dropdown-selected');
      
      raceOptions.classList.remove('show');
      raceSelected.classList.remove('active');
      
      options.classList.toggle('show');
      btSelected.classList.toggle('active');
    }
    
    // Close all dropdowns
    function closeAllDropdowns() {
      document.querySelectorAll('.dropdown-options').forEach(dropdown => {
        dropdown.classList.remove('show');
      });
      document.querySelectorAll('.dropdown-selected').forEach(selected => {
        selected.classList.remove('active');
      });
    }
    
    // Select race option
    function selectRaceOption(value, name, icon) {
      const selectedText = document.getElementById('raceSelectedText');
      const selectedIcon = document.getElementById('raceSelectedIcon');
      const dropdown = document.getElementById('raceDropdown');
      
      selectedText.textContent = name;
      selectedIcon.src = icon;
      selectedIcon.alt = name;
      
      dropdown.querySelector('.dropdown-selected').dataset.value = value;
      
      // Mark the selected option
      document.querySelectorAll('#raceOptions .dropdown-option').forEach(opt => {
        opt.classList.toggle('selected', opt.dataset.value === value);
      });
      
      document.getElementById('raceOptions').classList.remove('show');
      dropdown.querySelector('.dropdown-selected').classList.remove('active');
      
      filterMods();
      saveStateToStorage();
    }
    
    // Select body type option
    function selectBtOption(option) {
      const value = option.dataset.value;
      const text = option.querySelector('span').textContent;
      const icon = option.querySelector('img').src;
      
      const selectedText = document.getElementById('btSelectedText');
      const selectedIcon = document.getElementById('btSelectedIcon');
      const dropdown = document.getElementById('btDropdown');
      
      selectedText.textContent = text;
      selectedIcon.src = icon;
      selectedIcon.alt = text;
      
      dropdown.querySelector('.dropdown-selected').dataset.value = value;
      
      // Mark the selected option
      document.querySelectorAll('#btOptions .dropdown-option').forEach(opt => {
        opt.classList.toggle('selected', opt.dataset.value === value);
      });
      
      document.getElementById('btOptions').classList.remove('show');
      dropdown.querySelector('.dropdown-selected').classList.remove('active');
      
      filterMods();
      saveStateToStorage();
    }

    // Fonction de debounce pour limiter le taux d'appels d'une fonction
    function debounce(func, delay) {
      let timeoutId;
      return function(...args) {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        timeoutId = setTimeout(() => {
          func.apply(this, args);
          timeoutId = null;
        }, delay);
      };
    }
  </script>
</body>
</html>
